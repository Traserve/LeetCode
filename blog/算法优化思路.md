1. 先判断边界条件，尤其注意 int 类型边界问题。

2. 数组遍历的时候试一下逆序遍历，看是否比正序更好处理。

3. 先想出暴力解法，再根据暴力解法进行优化。例如双层循环使用双指针优化，可行的话再尝试从右往左是否可行（同向、逆向、相向）。

4. 递归尝试优化为迭代，使用循环处理。

5. 链表操作尝试添加虚拟头结点可避免维护头结点的麻烦。

6. Map 操作如果数据范围不大的话尝试改为数组，比如26个英文字母这样。

7. 在使用**异或**操作交换数组元素时，会遇到传入两个下标值相同的情况，这时异或操作实际上变成了`a^=a;a^=a;a^=a`；这时 a 的值会变成 0。解决方法：

   ```java
   public static void swap(int[] arr,int i,int j){
       if(i==j) return;
       a[i]^=a[j];
       a[j]^=a[i];
       a[i]^=a[j];
   }
   ```

8. 二叉树递归函数究竟什么时候需要返回值，什么时候不要返回值。

   搜索一条边的写法：

   ```java
   if (递归函数(root->left)) return ;
   
   if (递归函数(root->right)) return ;
   ```

   搜索整个树写法：

   ```java
   left = 递归函数(root->left);  // 左
   right = 递归函数(root->right); // 右
   left与right的逻辑处理;         // 中 
   ```

   **在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

   [112. 路径总和](blog/112. 路径总和.md)

   [113. 路径总和 II](blog/113. 路径总和 II.md)

   [236. 二叉树的最近公共祖先](blog/236. 二叉树的最近公共祖先.md)

9. 