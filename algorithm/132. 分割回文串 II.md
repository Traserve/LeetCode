# 132. 分割回文串 II

[题目链接](https://leetcode.cn/problems/palindrome-partitioning-ii/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文。

返回符合要求的 **最少分割次数** 。

**示例 1：**

```
输入：s = "aab"
输出：1
解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
```

**示例 2：**

```
输入：s = "a"
输出：0
```

**示例 3：**

```
输入：s = "ab"
输出：1 
```

**提示：**

- `1 <= s.length <= 2000`
- `s` 仅由小写英文字母组成

## 解法

### 1. 确定dp数组（dp table）以及下标的含义

dp[i]：范围是[0, i]的回文子串，最少分割次数是dp[i]。

### 2. 确定递推公式

来看一下由什么可以推出`dp[i]`。

如果要对长度为`[0, i]`的子串进行分割，分割点为`j`。

那么如果分割后，区间`[j + 1, i]`是回文子串，那么`dp[i]` 就等于 `dp[j] + 1`。

**为什么只看`[j + 1, i]`区间，不看`[0, j]`区间是不是回文子串呢？**

那么在回顾一下`dp[i]`的定义： 范围是`[0, i]`的回文子串，最少分割次数是`dp[i]`。

`[0, j]`区间的最小切割数量，我们已经知道了就是`dp[j]`。

此时就找到了递推关系，当切割点`j`在 `[0, i]` 之间时候，`dp[i] = dp[j] + 1`;

本题是要找到最少分割次数，所以遍历j的时候要取最小的`dp[i]`。

**所以最后递推公式为：`dp[i] = min(dp[i], dp[j] + 1);`**

注意这里不是要 `dp[j] + 1` 和 `dp[i]` 去比较，而是要在遍历`j`的过程中取最小的`dp[i]`！

可以有 `dp[j] + 1` 推出，当 `[j + 1, i]` 为回文子串

### 3. dp数组如何初始化

首先来看一下`dp[0]`应该是多少。

`dp[i]`： 范围是`[0, i]`的回文子串，最少分割次数是`dp[i]`。

那么`dp[0]`一定是0，长度为1的字符串最小分割次数就是0。这个是比较直观的。

在看一下非零下标的dp[i]应该初始化为多少？

在递推公式 `dp[i] = min(dp[i], dp[j] + 1)` 中我们可以看出每次要取最小的`dp[i]`。

那么非零下标的`dp[i]`就应该初始化为一个最大数，这样递推公式在计算结果的时候才不会被初始值覆盖！

如果非零下标的`dp[i]`初始化为0，在那么在递推公式中，所有数值将都是零。

非零下标的dp[i]初始化为一个最大数。

### 4. 确定遍历顺序

根据递推公式：`dp[i] = min(dp[i], dp[j] + 1);`

`j`是在`[0，i]`之间，所以遍历i的`for`循环一定在外层，这里遍历`j`的`for`循环在内层才能通过 计算过的`dp[j]`数值推导出`dp[i]`。

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int len = s.length();
        int[][] dp = new int[len + 1][len + 1];
        for (int i = len; i > 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j <= len; j++) {
                if (s.charAt(i - 1) == s.charAt(j - 1)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[1][len];
    }
}
```

